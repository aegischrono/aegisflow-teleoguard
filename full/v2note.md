 Pафиксируем сценарий в терминах Aegis + NotebookLM и архитектуру

- **База проверенных знаний** — уже прошли все Aegis‑проверки, это твой `Ground Truth`.
- **Ноутбук‑сессия (как NotebookLM)** — туда подтягиваются:
  - новые документы из интернета,
  - результаты Deep Research,
  - промежуточные гипотезы/выводы.
- **Фишка:**  
  Всё новое живёт сначала **внутри ноутбука**,  
  и **никогда не попадает** в основную базу, пока не пройдёт:
  - проверку согласованности,
  - TeleoGuard / "размышление от обратного",
  - нужные телологические/ценностные проверки.

Ниже — как это аккуратно оформить технически.

---

## 1. Общая схема: три слоя

Представь три логических слоя:

1. **CoreKB (Trusted)**  
   - AegisDB‑ядро: только проверенные артефакты.  
   - Это то, что прошло все EA/TeleoGuard‑проверки.  
   - Используется как "контекст по умолчанию" и точка опоры для рассуждений.

2. **Notebook Space (Sandbox / Session Graph)**  
   - Для каждого ноутбука создаётся **сессионный граф знаний**:
     - подключён к CoreKB только **на чтение**;
     - содержит:
       - загруженные сырые документы,
       - извлечённые из них утверждения,
       - гипотезы, промежуточные выводы.
   - Здесь можно быть более "грязным": экспериментировать, противоречить, спорить.

3. **Promotion Pipeline (Merge с тестами)**  
   - Слой, через который **единицы знания** из ноутбука  
     могут быть **подняты** в CoreKB,
   - но только после:
     - структурных проверок,
     - согласованности с ядром,
     - телологических проверок (служит ли это конечным целям),
     - (опционально) ручного ревью.

Это по сути **Git для мыслей**:

- CoreKB = `main` ветка,
- Каждый Notebook = `feature/*`,
- Promotion Pipeline = `pull request` + CI‑тесты.

---

## 2. Модель данных под это

Можно сделать это без лишних усложнений в той же БД.

### 2.1. Дополнительные поля/атрибуты

В `artifact` добавить:

- `scope`:
  - `'core'` — артефакт принадлежит CoreKB,
  - `'notebook'` — живёт только внутри конкретной сессии.
- `notebook_id`:
  - `NULL` для core,
  - конкретный UUID для артефактов в ноутбуке.
- `trust_level`:
  - `trusted` — прошёл все проверки (для core),
  - `candidate` — новое знание в ноутбуке, ещё не промотировано,
  - `rejected` — отвергнуто (но храним как опыт и для Anti‑Goodhart/обучения).

Пример:

```sql
ALTER TABLE artifact
  ADD COLUMN scope TEXT NOT NULL DEFAULT 'core',
  ADD COLUMN notebook_id TEXT,
  ADD COLUMN trust_level TEXT NOT NULL DEFAULT 'trusted';
```

И инвариант:

- `scope='core'` ⇒ `trust_level='trusted'` и `notebook_id IS NULL`.

### 2.2. Документы и утверждения

- Загруженный PDF / web‑страница:
  - `artifact(kind='doc', scope='notebook', trust_level='candidate', notebook_id='NB_123')`
- Извлечённые из документа факты:
  - `artifact(kind='claim'|'number', scope='notebook', trust_level='candidate', notebook_id='NB_123')`
  - `evidence_item` → источник = этот `doc` + url.

**Важно:**  
На уровне БД можно жёстко запретить:

- прямую вставку артефактов со `scope='core'` минуя promotion‑процесс.

Например:

- все операции "добавить в core" идут только через один сервис/функцию,
- или триггер, который запрещает `INSERT scope='core'`, если нет отметки о прохождении EndAnchor/TeleoGuard.

---

## 3. Как работает Notebook в терминах Aegis

### 3.1. Создание ноутбука

1. Пользователь создаёт Notebook:
   - в БД создаётся запись `notebook(id, owner, created_at, base_snapshot_ts)`:
     - `base_snapshot_ts` — время, на которое "заморожен" вид CoreKB для этого ноутбука (логически).

2. При запросах внутри ноутбука:

   - читает:
     - все артефакты `scope='core'` (состояние на сейчас / на срез),
     - и артефакты `scope='notebook'` с данным `notebook_id`.
   - LLM‑ответы для пользователя строятся по **объединённому графу**:
     - CoreKB + Notebook Space.

### 3.2. Загрузка новых источников (Deep Research)

Шаги:

1. Оператор `fetch_docs` (для ноутбука):
   - качает web‑страницы, pdf, и прочее.
   - создаёт `artifact(kind='doc', scope='notebook', trust_level='candidate', notebook_id='NB_123')`
   - `evidence_item` указывает оригинальный URL и т.п.

2. `extract_facts`:
   - LLM/регекс извлекают утверждения,
   - каждому создаётся:
     - `artifact(kind='claim'|'number', scope='notebook', trust_level='candidate', notebook_id='NB_123')`
     - `evidence_item` с привязкой к `doc`.

**Ничего из этого не идёт в CoreKB.**  
Это чисто "черновой слой ноутбука".

---

## 4. Фильтры и проверки перед попаданием в CoreKB

Ты хочешь, чтобы **части документов/утверждения никогда не попали в базу**, пока не пройдут:

- согласованность,
- размышление от обратного (teleology),
- ценностные правила.

Это идеальный use‑case для TeleoGuard (и Aegis в целом).

### 4.1. Локальные структурные проверки (внутри Notebook)

Перед тем как даже **кандидатку** рассматривать к промоушену:

- **Evidence‑first:**  
  - есть ли у `claim/number` хотя бы один источник?
  - не пустые ли `units` для чисел?
- **Unit Safety:**  
  - корректные ли единицы,
  - не возникло ли запрещённых операций (в вычисленных числах).
- **Временная актуальность:**  
  - источник не старее заданного окна (если это важно).

Это можно оформить как ECL‑шаги **внутри ноутбука**, которые помечают:

- артефакты, прошедшие базовые проверки — флагом `structurally_valid = true`,
- остальные остаются "грязными" и даже не рассматриваются к промоушену.

### 4.2. Согласованность с CoreKB

Следующий слой — сравнение с ядром:

1. Для каждого `candidate`‑артефакта в ноутбуке:
   - ищем в CoreKB:
     - совпадающие/похожие утверждения (по ключам, embeddings, полям),
     - противоречия (`contradicts`),
     - уже известные альтернативы.

2. Политика:

   - Если новый факт:
     - **поддерживает** существующее `trusted`‑утверждение,
     - или уточняет его (более новая дата, конкретизация),
     - и не ломает инварианты → потенциальный кандидат в CoreKB.

   - Если новый факт:
     - **противоречит** высоко‑`v` фактам в CoreKB:
       - создаём:
         - `edge(type='contradicts')`,
         - `artifact(kind='latent_risk', scope='notebook')` — маркёр "тут есть конфликт".
       - TeleoGuard/человек должны явно решить:
         - или это обновление (старое обесцениваем, новое повышаем),
         - или это "minority view" с низким `v`, который остаётся только в ноутбуке.

Без явного решения такие противоречащие факты **не промотируются** в CoreKB.

### 4.3. TeleoGuard / размышление от обратного

Теперь телология:

- у тебя есть **EndAnchor** для ядра (например, "база фактов по теме X должна быть…"):

```yaml
end_anchor:
  id: "core_kb_quality_for_topic_X"
  rules:
    min_validity: 0.8
    no_hard_value_violations: true
    max_internal_contradictions: 0
    required_provenance_depth: 2
```

TeleoGuard для промоушена делает:

1. **EndMirror:**  
   - смоделировать, как добавление нового кандидата в CoreKB
     изменит:
     - общий `v` связаных кластеров,
     - количество противоречий,
     - соответствие ValueConstraints.

2. **BackConstraints:**  
   - например:
     - "В CoreKB не может быть чисел без дат",
     - "Для ключевых метрик нужны ≥2 независимых источника".

3. **IAG (Intent–Action Gap):**
   - предложенное действие: "промотировать артефакт A в CoreKB".
   - оценивается:
     - улучшает ли оно шанс пройти EA,
     - не порождает ли новых рисков,
     - не противоречит ли ценностям/политикам.

   - Если IAG < порога:
     - `hard_fail` — блокируем промоушен,
     - создаём задание человеку: "разреши конфликт / подтверди вручную".

**Идея:** промоушен — это *серьёзный акт изменения знания*,  
и он ВСЕГДА проходит через TeleoGuard, как через CI pipeline.

---

## 5. Отвечая на твой ключевой тезис

> Они… никогда не попадут в базу, пока не пройдут проверку на согласованность, на размышление от обратного итд.

Технически это реализуется так:

1. **Жёсткий протокол "только через Promotion API":**
   - любые операции `INSERT scope='core'` / `UPDATE trust_level → 'trusted'`:
     - доступны только специальному сервису `PromotionService`,
     - и только после успешного прохождения:
       - структурных проверок,
       - проверки согласованности,
       - TeleoGuard (EndAnchor + IAG).

2. **UI‑уровень:**
   - в интерфейсе Notebook пользователь видит:
     - свои новые факты,
     - подсветку: какие из них потенциально можно "поднять",
     - где конфликты с ядром.
   - кнопка "принять в базу" на самом деле:
     - запускает promotion‑контракт (ECL),
     - TeleoGuard может:
       - сразу промотировать,
       - или сказать:
         - "нужны ещё источники",
         - "есть конфликт с таким‑то утверждением",
         - "нарушение политики — промоушен невозможен".

3. **Логика по умолчанию:**
   - всё новое → **навсегда может остаться только в рамках Notebook**:
     - как разовая гипотеза,
     - как временный рабочий материал для конкретного отчёта.
   - только явно одобренное → CoreKB.

---

## 6. Где здесь CAP и что выбрать

В этом более конкретном сценарии выбор ещё яснее:

- **CoreKB**:
  - нужен **строгий CP/ACID‑характер**:
    - консистентность важнее availability,
    - промоушен можно подождать, но "сломанной правды" быть не должно.

- **Notebook Space**:
  - может быть проще:
    - даже локальный стор (SQLite / локальная БД),
    - или тот же Postgres, но без жёстких инвариантов Aegis (там мы экспериментируем).
  - Но даже тут особого смысла в AP‑хаосе нет:
    - у тебя в ноутбуке небольшие объёмы, один пользователь/команда.

То есть архитектурно:

- "сердце" (CoreKB) — **CP/ACID**,
- Notebook — просто ещё один слой поверх (может жить в том же кластере, но логически отделён флагами `scope/notebook_id/trust_level`).

---

## 7. Если нужно ещё более "как NotebookLM"

Чтобы максимально "поприятнее" мыслить через NotebookLM:

- **Ноутбук = сессионный граф**:
  - контекст ответа ИИ:
    - CoreKB (trusted),
    - + Notebook (candidate).
- **Ответы ИИ**:
  - могут ссылаться и на CoreKB, и на notebook‑факты,
  - но **отчёт/решение, которое считается "официальным"**:
    - либо:
      - использует только CoreKB,
    - либо:
      - явно маркирует, какие части основаны на ещё не промотированных фактах.

- **Граница "официальное vs эксперимент":**
  - проходит по `trust_level` и `scope`:
    - всё "официальное" строится только на `scope='core' AND trust_level='trusted'`.

---
