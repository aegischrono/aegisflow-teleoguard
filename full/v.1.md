## 1. Коротко: что это и зачем

Aegis — это каркас для **проверяемого мышления и решений под неопределённостью**.  
Он превращает разрозненные данные, выводы и действия в:

- **граф доказательств** (что мы знаем и почему),
- **контракт процесса** (как мы к этому пришли),
- **телескоп с конца** (каждый шаг сверяется с финальной целью и ценностями).

---

## 2. Техническая сторона: как это сделать и что важно

### 2.1. AegisDB — хранилище знаний с доказательствами

**Задача:** не просто хранить данные, а **гарантировать эпистемологию**: откуда это, насколько надёжно, в каких единицах и границах применимости.

**Базовые сущности**

1. `artifact` — узел графа знаний:
   - `kind`: `claim`, `number`, `table`, `report`, `decision`, `latent_risk`
   - `content`: JSON (текст утверждения, структура, параметры)
   - `units`: обязательны для чисел (`USD`, `kg`, `m^2/s`)
   - `v` (validity 0–1) — надёжность утверждения
   - `r` (risk 0–1) — риск / величина возможного ущерба
   - `state`: `draft` | `resolved` | `stale` | `invalidated`
   - `sources`: массив источников (url, цитаты, ref-id)
   - `valid_from` / `valid_to`: временные рамки действия факта
   - `alt_group_id`: принадлежность к группе альтернатив

2. `evidence_item` — атомарное доказательство:
   - `level`: `opinion` | `citation` | `replicated` | `unit_test` | `simulation` | `formal_proof`
   - `weight`: насколько сильно это доказательство (0–1)
   - `source_url`, `source_hash`
   - `independence_score` (0–1) — степень независимости от других источников (может считаться offline)

3. `edge` — связь между артефактами:
   - типы: `supports`, `contradicts`, `requires`, `refines`, `alternative_of`
   - глобальное требование: **граф по `requires` должен быть DAG** (без циклов)

4. `journal_event` — неизменяемый лог всех действий:
   - `operation`, `inputs`, `outputs`
   - для ИИ-операций: `model_id`, `prompt_hash`, `seed`
   - `prev_hash` — связываем в цепочку для проверяемости

**Критические инварианты (что важно реализовать жёстко)**

1. **Evidence-first:**  
   - `artifact` с `kind in ('claim','number')` не может быть сохранён без `sources != []`.
2. **Unit safety:**  
   - все числа с единицами; операции над числами проходят через `UnitContract`:
     - запрещены бессмысленные (`kg + meter`);
     - конверсия валют/единиц только с явным курсом + датой.
3. **Monotonic validity:**  
   - `v` увеличивается только при добавлении **независимых** источников.
   - базовая формула:  
     `v = 1 - Π_i (1 - w_i * level_weight_i * independence_i)`
4. **Полная трассируемость:**  
   - всё пишется в `journal_event`, никаких "тихих" изменений.
5. **Альтернативы как класс:**  
   - в группе `alt_group_id` в финале должен быть ровно один `resolved`, остальные — явно зафиксированы как отвергнутые/отложенные.

**Технологический минимум**

- PostgreSQL или аналог (реляционка + JSONB).
- Хранимые процедуры/триггеры для:
  - проверки инвариантов (evidence, units, DAG),
  - пересчёта `v`,
  - простановки `stale` по графу при изменениях.

---

### 2.2. AegisFlow — слой процесса и оркестрации

**Задача:** сделать мышление **повторяемым**.  
Не "мы как‑то подумали", а "мы прогнали такой‑то контракт и получили этот результат".

**Контракт (ECL-lite)**

YAML/JSON-описание анализа / решения:

```yaml
goal: "answer_with_proof"
end_anchors:
  - id: "final_report"
    rules:
      min_validity: 0.75
      min_alternatives: 2

steps:
  - fetch_docs: {source: "./docs"}
  - extract_facts: {mode: "regex|llm", tag: "raw_claims"}
  - assess_validity: {targets: "raw_claims"}
  - generate_alternatives: {for: "decision_X", count: 3}
  - endmirror: {}
  - intent_gap: {max_penalty: 0}
  - assemble_report: {format: "html"}
```

**Основные операторы, которые нужно реализовать первыми**

- `fetch_docs` — загрузка источников (файлы, web, API → `artifact` + `evidence_item`).
- `extract_facts` — разметка фактов (LLM/регекс) → `claim`-артефакты.
- `assess_validity` — пересчёт `v` на основе привязанных `evidence_item`.
- `generate_alternatives` — создание группы альтернатив + связей `alternative_of`.
- `assemble_report` — сбор конечного отчёта как `artifact(kind='report')` со ссылками на все использованные узлы.

**Scheduler Ω (планировщик шагов)**

Он держит "фронтир" возможных следующих шагов и сортирует их по приоритету:

- вход:
  - список доступных шагов из контракта,
  - текущие метрики (что уже известно, где пробелы),
  - ограничения по времени/стоимости.
- приоритизация по:
  - Value of Information (VOI) — насколько шаг повысит уверенность в ключевых узлах;
  - Cost of Delay (CoD) — насколько опасно откладывать;
  - риск/новизна;
  - Retrocausal VOI (rVOI) — как шаг улучшит шансы пройти EndAnchor.

Реализация MVP:

- простая функция приоритета:  
  `priority = a*VOI + b*CoD - c*cost + d*rVOI`
- очередь задач (например, Redis / внутренняя в сервисе),
- обработчик, который вытаскивает самую приоритетную и выполняет.

---

### 2.3. TeleoGuard — стратегическое выравнивание

**Задача:** не дать процессу "уплыть" от цели. Каждый крупный шаг проходит **прескрин** на соответствие конечному замыслу и ценностям.

**Ключевые элементы**

1. **EndAnchor (EA)** — формальное описание успеха:

```json
{
  "id": "final_report",
  "target_kind": "report",
  "rules": {
    "min_validity": 0.8,
    "min_alternatives": 2,
    "max_risk": 0.3,
    "no_hard_value_violations": true
  }
}
```

- может быть несколько EA → TeleoDiversity (разные сценарии успеха).

2. **BackConstraints (BC)** — обратные ограничения от конца к началу:
   - генерируются из EA для ранних шагов:
     - "все ключевые числовые показатели должны иметь ≥2 независимых источника",
     - "запрещены решения без альтернативной проверки".

3. **Penultimate Sentinels (PS)** — "предфинишные стражи":
   - проверки на узлах за 1–2 шага до финала:
     - "перед публикацией отчёта: нет ли противоречащих фактов с высоким `v`?"

4. **EndMirror** — быстрый прогон "что, если финал прямо сейчас?":
   - вычисляет, с какой вероятностью текущий граф пройдёт EA,
   - возвращает "запас по правилам" (margin).

5. **Intent–Action Gap (IAG)** — метрика дрейфа:
   - считает, насколько предлагаемый шаг:
     - улучшает / ухудшает шансы пройти EA,
     - добавляет риск,
     - нарушает ValueConstraints (этика, бренд).
   - по порогам IAG:
     - `Pass` — шаг выполняется;
     - `Soft-fail` — показать альтернативы, задать вопросы;
     - `Hard-fail` — блок + сократические вопросы пользователю.

**Технически**

- отдельный сервис/модуль, вызываемый перед выполнением "крупных" шагов.
- на вход:
  - описание предлагаемых изменений (шаг контракта),
  - срез текущего графа (ключевые KPI).
- на выход:
  - решение (`pass` / `soft_fail` / `hard_fail`),
  - метрики (IAG, изменения по EA),
  - список рекомендаций/вопросов.

---

### 2.4. Интеграция с LLM / ИИ

Aegis принципиально **не верит "голым" ответам ИИ**:

- любой вызов модели:
  - логируется в `journal_event` с `model_id`, `prompt_hash`, `seed`;
  - результат либо:
    - разбивается на `artifact` + `evidence_item`,
    - либо идёт в служебный слой (например, переписка, не факт).

Основной паттерн:

1. LLM генерирует черновой вывод / объяснение.
2. Специальный оператор:
   - извлекает из текста факты,
   - привязывает их к источникам (URL, DOI, внутренние документы),
   - пересчитывает `v`.
3. Без привязки к источнику факт **не считается знанием**.

---

### 2.5. Минимальная инфраструктура

- **Бэкенд:**
  - Postgres (AegisDB),
  - сервис на Python/Go/Node:
    - REST/gRPC API к артефактам, графу, журналу,
    - выполнение ECL-lite контрактов,
    - интеграция с LLM API.
- **TeleoGuard:** как отдельный модуль (можно в том же сервисе).
- **UI (минимум):**
  - просмотр графа доказательств для ответа/решения,
  - конструктор простых контрактов (wizard → генерит ECL-lite),
  - панель TeleoGuard (показывает EA, IAG, блокировки).

---

## 3. Как использовать: ключевые сценарии и выгоды

### 3.1. Аналитика и отчёты

**Что делаем:**

- Описываем контрактом:
  - какие источники читаем,
  - как выдёргиваем факты,
  - как считаем валидность,
  - как собираем отчёт.
- Каждый тезис в отчёте — `artifact` со ссылками:
  - на первичные источники,
  - на промежуточные выводы.

**Выгоды:**

- Любой читатель может "провалиться" из вывода в доказательства.
- Легко ревьюить: видно, где домыслы, а где жёсткие факты.
- Проще обновлять отчёты: меняем факты → зависимые узлы помечаются `stale`.

---

### 3.2. Обучение: Verifiable Learning Manifesto

**Идея:** сломать иллюзию "мне кажется, что я понял".

**Техника:**

- Каждый "понял" → это `claim` от пользователя.
- Система **тут же** требует действий:
  - задача / код / пример — это `evidence_item` к этому `claim`.
  - пока нет пройденных задач → `claim` не проходит EA для темы.
- TeleoGuard блокирует переход к следующей теме, если:
  - нет достаточного уровня `v` по базовым концептам.

**A/B Chat (Mentor / Muse):**

- **Circuit A (Mentor)**:
  - мощная модель, отвечает детально, но только на хорошо сформулированные запросы.
- **Circuit B (Muse)**:
  - дешёвая модель-переформулировщик:
    - из сырых мыслей ученика генерит 5–10 чётких промтов.
- Пользователь:
  - общается не "на языке машины", а "по‑человечески",
  - Muse помогает превратить хаос в чёткий запрос к Mentor.

**Выгоды:**

- Реальный контроль понимания (через действия).
- Автоматизированная "сократическая" проверка.
- Помощь в формулировании собственных мыслей, а не только ответы.

---

### 3.3. Сохранение критической экспертизы: Legacy Protocol

**Идея:** сделать из уходящего эксперта **тренера ИИ**, а не лектора.

**Процесс (как в Git):**

1. `Commit` — эксперт формулирует мысль / принцип → `artifact`.
2. `Branch` — ИИ генерирует:
   - простые объяснения,
   - аналогии,
   - возможные ответы студента → ветки.
3. `Code Review` — эксперт не пишет, а **оценивает**:
   - что верно, что искажено.
   - одобряет / просит переработку веток.
4. `Peer Review` — ученики голосуют за самые понятные из **одобренных экспертом**.
5. `Merge` — версия с макс. `корректность * понятность` идёт в базу.

**Технически:**

- AegisDB хранит:
  - кто придумал (expert id),
  - какие ветки создал ИИ,
  - какие версии эксперт одобрил,
  - какие пользователи выбрали как понятные.

**Выгоды:**

- Остаётся не просто текстовая база, а **поведение эксперта**:
  - как он бы объяснил,
  - какие варианты считал опасными/упрощающими чрезмерно.
- Можно строить "цифрового двойника" эксперта для будущих поколений.

---

### 3.4. Оркестрация ИИ-агентов и систем принятия решений

**Use-case:**

- сложный пайплайн из нескольких агентов/сервисов:
  - сбор данных, анализ, генерация гипотез, проверка, решение.
- AegisFlow описывает это как контракт,
- TeleoGuard:
  - не даёт шагам противоречить финальным целям (бизнес, безопасность, бренд),
  - следит за Intent–Action Gap.

**Выгоды:**

- **Прозрачная** цепочка действий агента:
  - каждый шаг объясним,
  - видно, какие факты на что повлияли.
- Можно встроить юристов/комплаенс прямо в EA/ValueConstraints:
  - шаги, нарушающие политику, блокируются на уровне системы, а не по "чести" модели.

---

### 3.5. Инженерия и железо: TeleoSilicon (пример домена)

TeleoSilicon — применение тех же принципов к процессорам:

- TeleoGoals для PPA, yield, SLO.
- BackConstraints для:
  - архитектуры (SDE),
  - физики кристалла (PRE),
  - выполнения кода (ExecutionPlane).
- Исторические траектории решений + результатов → модель, которая советует:
  - какие изменения в дизайне / рантайме с наибольшей вероятностью ведут к цели.

**Выгоды:**

- Цели производительности/энергоэффективности явно "давят назад" на решения.
- Разброс кремния (частоты, утечки, дефекты) используется как ресурс для SKU, а не просто брак.
- Runtime‑слой (планировщик, компилятор) тоже подчинён TeleoGoals, а не живёт отдельно.

---

## 4. Ключевые преимущества подхода Aegis

1. **Проверяемость и повторяемость:**
   - любой вывод можно "раскрутить" до источников,
   - одинаковый контракт на тех же данных → тот же результат (с учётом зафиксированных моделей).

2. **Стратегическая целостность:**
   - от начала до конца видно, служит ли шаг цели или нет (TeleoGuard, IAG).
   - снимает иллюзию "ну мы же что‑то делаем" → "это действительно ведёт к цели?".

3. **Единая архитектурная рамка для разных доменов:**
   - аналитика, обучение, сохранение экспертизы, ИИ‑агенты, железо — разные поверхности, **один и тот же каркас**:
     - граф доказательств + контракт процесса + TeleoGuard.

4. **Устойчивость и защита от "магии ИИ":**
   - модели — не "оракул", а инструмент,
   - знания рождаются только после привязки к источникам и прохождения проверок.

5. **Повышение качества решений без увеличения ручного контроля:**
   - многие проверки (единицы, источники, альтернативы, соответствие целям) автоматизированы.

---

## 5. Практический путь: что делать первым

1. **Шаг 1 — AegisDB (минимум):**
   - таблицы `artifact`, `evidence_item`, `edge`, `journal_event`,
   - триггеры:
     - запрет "голых" фактов без источника,
     - обязательные единицы для чисел,
     - DAG-проверка по `requires`.

2. **Шаг 2 — Простые контракты (AegisFlow):**
   - один сервис, который выполняет несколько базовых шагов:
     - `fetch_docs`, `extract_facts`, `assess_validity`, `assemble_report`.
   - без сложного Scheduler Ω — сначала линейное выполнение.

3. **Шаг 3 — TeleoGuard v0:**
   - EndAnchor с парой правил (min_validity, min_alternatives),
   - простая проверка перед финальным шагом:
     - если не прошли EA → блок + список, чего не хватает.

4. **Шаг 4 — Расширение под конкретный домен:**
   - выбери 1 домен (аналитика отчётов, обучение или Legacy),
   - добавь специфические операторы/правила (например, экзамен‑задачи в обучении),
   - начни собирать реальные траектории: "контракт → результат → успех/провал".

5. **Шаг 5 — Развитие Scheduler Ω и TeleoGuard:**
   - добавить VOI/CoD в планировщик,
   - добавить Penultimate Sentinels, EndMirror, IAG,
   - начать "учить" систему на собственных данных (какие шаги чаще приводят к успешному прохождению EA).

